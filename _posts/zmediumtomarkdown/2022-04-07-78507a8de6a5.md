---
title: "Practical Application Record of Design Patterns"
author: "ZhgChgLi"
date: 2022-04-07T14:49:17.715+0000
last_modified_at: 2024-04-14T02:03:19.276+0000
categories: "Pinkoi Engineering"
tags: ["ios-app-development","design-patterns","socketio","websocket","finite-state-machine"]
description: "Problems encountered and solutions applied to Design Patterns when encapsulating Socket.IO Client Library requirements"
image:
  path: /assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg
pin: true
render_with_liquid: false
---

### Practical Application Record of Design Patterns

Problems encountered and solutions applied to Design Patterns when encapsulating Socket.IO Client Library requirements


![Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}](/assets/78507a8de6a5/1*mkG0YtCzyPQpU9MG0HI79w.jpeg)

Photo by [Daniel McCullough](https://unsplash.com/@d_mccullough?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText){:target="_blank"}
### Preface

This article is a real development requirement, recording the scenarios where Design Patterns were applied to solve problems; the content will cover the background of the requirement, the actual problem scenarios (What?), why the Pattern was applied to solve the problem (Why?), and how it was used in implementation (How?). It is recommended to read from the beginning for better coherence.


> _This article will introduce four scenarios encountered during the development of this requirement and seven Design Patterns applied to solve these scenarios._ 




### Background
#### Organizational Structure

Our company split into Feature Teams (multiple) and Platform Team this year; the former mainly handles user-end requirements, while the Platform Team faces internal members of the company. One of the tasks is technology introduction, infrastructure, and ensuring systematic integration, paving the way for Feature Teams when developing requirements.
#### Current Requirement

Feature Teams need to change the original messaging function (fetching message data via API when entering the page, refreshing to get the latest messages) to real-time communication (receiving the latest messages in real-time, sending messages).
#### Platform Team Work

The Platform Team focuses not only on the current real-time communication requirement but also on long-term construction and reusability. After evaluation, the webSocket bidirectional communication mechanism is indispensable in modern apps. Besides this requirement, there will be many opportunities to use it in the future. Given the available human resources, we decided to assist in designing and developing the interface.

**Goals:**
- Encapsulate Pinkoi Server Side and Socket.IO communication, authentication logic
- Encapsulate cumbersome Socket.IO operations, providing an extensible and easy-to-use interface based on Pinkoi's business needs
- Unify the interface across both platforms **(Socket.IO's Android and iOS Client Side Library support different functions and interfaces)**
- Feature end does not need to understand the Socket.IO mechanism
- Feature end does not need to manage complex connection states
- Future webSocket bidirectional communication requirements can be directly used


**Time and Manpower:**
- One person each for iOS & Android
- Development schedule: 3 weeks

#### Technical Details

This feature will be supported on Web, iOS, and Android platforms; the webSocket bidirectional communication protocol will be introduced to achieve this, with the backend expected to directly use the [Socket.io](http://socket.io/){:target="_blank"} service.


> **_First of all, Socket \!= WebSocket_** 





For details on Socket and WebSocket, refer to the following articles:
- [Differences between Socket, WebSocket, and Socket.io](https://leesonhsu.blogspot.com/2018/07/socketwebsocketsocketio.html){:target="_blank"}
- [Why not use socket directly, but define a new websocket?](https://github.com/onlyliuxin/coding2017/issues/497){:target="_blank"}

In short:
```
Socket is an abstract interface for the TCP/UDP transport layer, while WebSocket is a transport protocol at the application layer.
The relationship between Socket and WebSocket is like the relationship between a dog and a hot dog, they are unrelated.
```

![](/assets/78507a8de6a5/1*MC_nQC382khMeWggLejWOA.jpeg)

Socket.IO is an abstraction layer over Engine.IO, and Engine.IO is an abstraction over WebSocket. Each layer is responsible for communication up and down, and cross-layer operations are not allowed (e.g., Socket.IO directly operating WebSocket connections).

Socket.IO/Engine.IO, in addition to basic WebSocket connections, also implements many convenient and useful features (e.g., offline event sending mechanism, HTTP request-like mechanism, Room/Group mechanism, etc.).

The main responsibility of the Platform Team is to bridge the logic between Socket.IO and Pinkoi Server Side, providing it for the upper Feature Teams to use during development.
#### [Socket.IO Swift Client](https://github.com/socketio/socket.io-client-swift){:target="_blank"} has pitfalls
- It hasn't been updated for a long time (the latest version is still in 2019), and it's uncertain if it's still maintained.
- Client & Server Side Socket IO versions need to match. The Server Side can add `{allowEIO3: true}` / or the Client Side can specify the same version `.version`, otherwise, it won't connect.
- Many naming conventions and interfaces do not match the official website examples.
- The examples on the Socket.io official website are all for the web, but the Swift Client **does not necessarily support all the features written on the official website**. In this implementation, we found that the iOS library did not implement the offline event sending mechanism (we implemented it ourselves, please continue reading).

> **_It is recommended to experiment with the mechanisms you want to use before adopting Socket.IO._**

> _Socket.IO Swift Client is a wrapper based on the **[Starscream](https://github.com/daltoniam/Starscream){:target="_blank"}** WebSocket Library, and can be downgraded to use Starscream if necessary._

```
Background information ends here, let's get to the main topic.
```
### Design Patterns

Design patterns are simply solutions to common problems in software design. You don't have to use design patterns to develop, design patterns are not applicable to all scenarios, and no one says you can't come up with new design patterns.

![[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}](/assets/78507a8de6a5/1*MAm5WPynbv7M9tdmW2lNGQ.jpeg)

[The Catalog of Design Patterns](https://refactoring.guru/design-patterns/catalog){:target="_blank"}

However, the existing design patterns (The 23 Gang of Four Design Patterns) are common knowledge in software design. When mentioning XXX Pattern, everyone will have a corresponding architectural blueprint in mind, no need for much explanation, and subsequent maintenance will be easier to understand the context. These are industry-verified methods that do not require much time to review object dependency issues. Choosing the right pattern for the right scenario can reduce communication and maintenance costs and improve development efficiency.

> **_Design patterns can be combined, but it is not recommended to modify existing design patterns, forcefully apply them, or apply patterns that do not fit the classification (e.g., using the Chain of Responsibility pattern to generate objects), as this will lose the meaning of using them and may cause misunderstandings for those who take over later._**

#### Design Patterns mentioned in this article:
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}
- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}
- [Finite-State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"} + [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}
- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}

Will explain later in detail what scenarios are used and why they are used.

> _This article focuses on the application of Design Patterns, not the operation of Socket.IO. Some examples are simplified for convenience and **cannot be applied to real Socket.IO encapsulation**._

> _Due to limited space, this article will not introduce the structure of each design pattern in detail. Please click on the links of each pattern to understand the structure before continuing to read._

> _Demo Code will be written in Swift._

### Requirement Scenario 1.
#### What?
- Reuse the same object when requesting a connection with the same Path on different pages or objects.
- The connection needs to be an abstract interface, not directly dependent on the Socket.IO object.

#### Why?
- Reduce memory overhead and the time and traffic cost of repeated connections.
- Reserve space for future replacement with other frameworks.

#### How?
- [Singleton Pattern](https://refactoring.guru/design-patterns/singleton){:target="_blank"}: Creational Pattern, ensures that a class has only one instance.
- [Flyweight Pattern](https://refactoring.guru/design-patterns/flyweight){:target="_blank"}: Structural Pattern, reuses objects by sharing common states among multiple objects.
- [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"}: Creational Pattern, abstracts the object creation method, allowing it to be replaced externally.

**Practical Use Case:**

![](/assets/78507a8de6a5/1*flQa_EfErGBwbmEwpI7ZgQ.png)

- **Singleton Pattern:** `ConnectionManager` is the only object that exists in the App Lifecycle, used to manage `Connection` access operations.
- **Flyweight Pattern:** `ConnectionPool` is a shared pool of connections. Connections are retrieved from this pool, and if the URL Path is the same, the existing connection in the pool is reused. `ConnectionHandler` acts as an external operator and state manager for `Connection`.
- **Factory Pattern:** `ConnectionFactory` works with the Flyweight Pattern. If no reusable `Connection` is found in the pool, this factory interface is used to create one.

```swift
import Combine
import Foundation

protocol Connection {
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

protocol ConnectionFactory {
    func create(url: URL) -> Connection
}

class ConnectionPool {
    
    private let connectionFactory: ConnectionFactory
    private var connections: [Connection] = []
    
    init(connectionFactory: ConnectionFactory) {
        self.connectionFactory = connectionFactory
    }
    
    func getOrCreateConnection(url: URL) -> Connection {
        if let connection = connections.first(where: { $0.url == url }) {
            return connection
        } else {
            let connection = connectionFactory.create(url: url)
            connections.append(connection)
            return connection
        }
    }
    
}

class ConnectionHandler {
    private let connection: Connection
    init(connection: Connection) {
        self.connection = connection
    }
    
    func getConnectionUUID() -> UUID {
        return connection.id
    }
}

class ConnectionManager {
    static let shared = ConnectionManager(connectionPool: ConnectionPool(connectionFactory: SIOConnectionFactory()))
    private let connectionPool: ConnectionPool
    private init(connectionPool: ConnectionPool) {
        self.connectionPool = connectionPool
    }
    
    //
    func requestConnectionHandler(url: URL) -> ConnectionHandler {
        let connection = connectionPool.getOrCreateConnection(url: url)
        return ConnectionHandler(connection: connection)
    }
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

class SIOConnectionFactory: ConnectionFactory {
    func create(url: URL) -> Connection {
        //
        return SIOConnection(url: url)
    }
}
//

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)
print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/1")!).getConnectionUUID().uuidString)

print(ConnectionManager.shared.requestConnectionHandler(url: URL(string: "wss://pinkoi.com/2")!).getConnectionUUID().uuidString)

// output:
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// D99F5429-1C6D-4EB5-A56E-9373D6F37307
// 599CF16F-3D7C-49CF-817B-5A57C119FE31
```
### Requirement Scenario 2.
#### What?

As described in the background technical details, the `Send Event` of the Socket.IO Swift Client does not support offline sending (but the Web/Android version of the Library does), so this functionality needs to be implemented on the iOS side.

```
Interestingly, Socket.IO Swift Client - onEvent supports offline subscription.
```

#### Why?
- Unified cross-platform functionality
- Code is easier to understand

#### How?
- [Command Pattern](https://refactoring.guru/design-patterns/command){:target="_blank"}: A behavioral pattern that encapsulates operations into objects, providing queueing, delay, cancellation, and other collective operations.

![](/assets/78507a8de6a5/1*O9zc28nMx64HDiDy4aiexA.png)

- **Command Pattern:** `SIOManager` is the lowest-level encapsulation for communicating with Socket.IO. The `send` and `request` methods are operations on the Socket.IO Send Event. When it detects that the current Socket.IO is in a disconnected state, it puts the request parameters into `bufferedCommands`, and when it reconnects, it processes them one by one (First In First Out).

```swift
protocol BufferedCommand {
    var sioManager: SIOManagerSpec? { get set }
    var event: String { get }
    
    func execute()
}

struct SendBufferedCommand: BufferedCommand {
    let event: String
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.send(event)
    }
}

struct RequestBufferedCommand: BufferedCommand {
    let event: String
    let callback: (Data?) -> Void
    weak var sioManager: SIOManagerSpec?
    
    func execute() {
        sioManager?.request(event, callback: callback)
    }
}

protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected
```

Similarly, it can also be applied to `onEvent`.

Extension: You can further apply the [Proxy Pattern](https://refactoring.guru/design-patterns/proxy){:target="_blank"} to treat the Buffer functionality as a kind of Proxy.
### Scenario 3.
#### What?

Connection has multiple states, with orderly transitions between states, and each state allows different operations.

![](/assets/78507a8de6a5/1*DBl6K1cPQc_cHOYXZ1VQ8A.jpeg)

![](/assets/78507a8de6a5/1*-Xk_TT6SMW5Jxd-c8iSCcw.jpeg)

- Created: Object is created, allows -> `Connected` or directly to `Disconnected`
- Connected: Connected to Socket.IO, allows -> `Disconnected`
- Disconnected: Disconnected from Socket.IO, allows -> `Reconnecting`, `Released`
- Reconnecting: Trying to reconnect to Socket.IO, allows -> `Connected`, `Disconnected`
- Released: Object is marked for garbage collection, no operations or state transitions are allowed

#### Why?
- The logic and representation of state transitions are not easy
- Each state needs to restrict operation methods (e.g., State = Released cannot Call Send Event), directly using if..else will make the program difficult to maintain and read

#### How?
- [Finite State Machine](https://en.wikipedia.org/wiki/Finite-state_machine){:target="_blank"}: Manage state transitions
- [State Pattern](https://refactoring.guru/design-patterns/state){:target="_blank"}: Behavioral Pattern, different responses when the object's state changes

![](/assets/78507a8de6a5/1*NgehABZTiXL_fFEYQh63Hg.png)

- **Finite State Machine**: `SIOConnectionStateMachine` is the state machine implementation, `currentSIOConnectionState` is the current state, `created, connected, disconnected, reconnecting, released` lists the possible states of this state machine.
`enterXXXState() throws` is the implementation of allowed and disallowed (throw error) transitions from the Current State to a certain state.
- **State Pattern**: `SIOConnectionState` is the interface abstraction for operation methods used by all states.

```swift
protocol SIOManagerSpec: AnyObject {
    func connect()
    func disconnect()
    func onEvent(event: String, callback: @escaping (Data?) -> Void)
    func send(_ event: String)
    func request(_ event: String, callback: @escaping (Data?) -> Void)
}

enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

class SIOManager: SIOManagerSpec {
        
    var state: ConnectionState = .disconnected {
        didSet {
            if state == .connected {
                executeBufferedCommands()
            }
        }
    }
    
    private var bufferedCommands: [BufferedCommand] = []
    
    func connect() {
        state = .connected
    }
    
    func disconnect() {
        state = .disconnected
    }
    
    func send(_ event: String) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: SendBufferedCommand(event: event, sioManager: self))
            return
        }
        
        print("Send:\(event)")
    }
    
    func request(_ event: String, callback: @escaping (Data?) -> Void) {
        guard state == .connected else {
            appendBufferedCommands(connectionCommand: RequestBufferedCommand(event: event, callback: callback, sioManager: self))
            return
        }
        
        print("request:\(event)")
    }
    
    func onEvent(event: String, callback: @escaping (Data?) -> Void) {
        //
    }
    
    func appendBufferedCommands(connectionCommand: BufferedCommand) {
        bufferedCommands.append(connectionCommand)
    }
    
    func executeBufferedCommands() {
        // First in, first out
        bufferedCommands.forEach { connectionCommand in
            connectionCommand.execute()
        }
        bufferedCommands.removeAll()
    }
    
    func removeAllBufferedCommands() {
        bufferedCommands.removeAll()
    }
}

let manager = SIOManager()
manager.send("send_event_1")
manager.send("send_event_2")
manager.request("request_event_1") { _ in
    //
}
manager.state = .connected

//

class SIOConnectionStateMachine {
    
    private(set) var currentSIOConnectionState: SIOConnectionState!

    private var created: SIOConnectionState!
    private var connected: SIOConnectionState!
    private var disconnected: SIOConnectionState!
    private var reconnecting: SIOConnectionState!
    private var released: SIOConnectionState!
    
    init() {
        self.created = SIOConnectionCreatedState(stateMachine: self)
        self.connected = SIOConnectionConnectedState(stateMachine: self)
        self.disconnected = SIOConnectionDisconnectedState(stateMachine: self)
        self.reconnecting = SIOConnectionReconnectingState(stateMachine: self)
        self.released = SIOConnectionReleasedState(stateMachine: self)
        
        self.currentSIOConnectionState = created
    }
    
    func enterConnected() throws {
        if [created.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(connected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Connected")
        }
    }
    
    func enterDisconnected() throws {
        if [created.connectionState, connected.connectionState, reconnecting.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(disconnected)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Disconnected")
        }
    }

    func enterReconnecting() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(reconnecting)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Reconnecting")
        }
    }

    func enterReleased() throws {
        if [disconnected.connectionState].contains(currentSIOConnectionState.connectionState) {
            enter(released)
        } else {
            throw SIOConnectionStateMachineError("\(currentSIOConnectionState.connectionState) can't enter to Released")
        }
    }
    
    private func enter(_ state: SIOConnectionState) {
        currentSIOConnectionState = state
    }
}


protocol SIOConnectionState {
    var connectionState: ConnectionState { get }
    var stateMachine: SIOConnectionStateMachine { get }
    init(stateMachine: SIOConnectionStateMachine)

    func onConnected() throws
    func onDisconnected() throws
    
    
    func connect(socketManager: SIOManagerSpec) throws
    func disconnect(socketManager: SIOManagerSpec) throws
    func release(socketManager: SIOManagerSpec) throws
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws
    func send(socketManager: SIOManagerSpec, event: String) throws
}

struct SIOConnectionStateMachineError: Error {
    let message: String

    init(_ message: String) {
        self.message = message
    }

    var localizedDescription: String {
        return message
    }
}

class SIOConnectionCreatedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .created
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("CreatedState can't disconnect!")
    }
}

class SIOConnectionConnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .connected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }
    
    func onConnected() throws {
        //
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ConnectedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionDisconnectedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .disconnected
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        //
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReleased()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        try stateMachine.enterReconnecting()
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReconnectingState: SIOConnectionState {
    
    let connectionState: ConnectionState = .reconnecting
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        try stateMachine.enterConnected()
    }
    
    func onDisconnected() throws {
        try stateMachine.enterDisconnected()
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't release!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReconnectState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        // allow
        // can use Helper to reduce the repeating code
        // e.g. helper.XXX(socketManager: SIOManagerSpec, ....)
    }
}

class SIOConnectionReleasedState: SIOConnectionState {
    
    let connectionState: ConnectionState = .released
    let stateMachine: SIOConnectionStateMachine
    
    required init(stateMachine: SIOConnectionStateMachine) {
        self.stateMachine = stateMachine
    }

    func onConnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onConnected!")
    }
    
    func onDisconnected() throws {
        throw SIOConnectionStateMachineError("ReleasedState can't onDisconnected!")
    }
    
    func release(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't release!")
    }
    
    func request(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't request!")
    }
    
    func onEvent(socketManager: SIOManagerSpec, event: String, callback: @escaping (Data?) -> Void) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't receiveOn!")
    }
    
    func send(socketManager: SIOManagerSpec, event: String) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't send!")
    }
    
    func connect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't connect!")
    }
    
    func disconnect(socketManager: SIOManagerSpec) throws {
        throw SIOConnectionStateMachineError("ReleasedState can't disconnect!")
    }
}

do {
    let stateMachine = SIOConnectionStateMachine()
    // mock on socket.io connect:
    // socketIO.on(connect){
    try stateMachine.currentSIOConnectionState.onConnected()
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    try stateMachine.currentSIOConnectionState.release(socketManager: manager)
    try stateMachine.currentSIOConnectionState.send(socketManager: manager, event: "test")
    // }
} catch {
    print("error: \(error)")
}

// output:
// error: SIOConnectionStateMachineError(message: "ConnectedState can't release!")
```
### Scenario 3.
#### What?

Combining scenarios 1 and 2, with the `ConnectionPool` flyweight pool and State Pattern state management; we continue to extend further. As stated in the background goals, the Feature side does not need to manage the connection mechanism behind the Connection. Therefore, we have established a poller (named `ConnectionKeeper`) that periodically scans the strongly held `Connection` in the `ConnectionPool` and performs operations in the following situations:
- `Connection` is in use and the state is not `Connected`: Change the state to `Reconnecting` and try to reconnect
- `Connection` is not in use and the state is `Connected`: Change the state to `Disconnected`
- `Connection` is not in use and the state is `Disconnected`: Change the state to `Released` and remove it from the `ConnectionPool`

#### Why?
- The three operations have a hierarchical relationship and are mutually exclusive (disconnected -> released or reconnecting)
- Flexible to swap and add condition operations
- Without encapsulation, the three judgments and operations can only be written directly in the method (difficult to test the logic within)
- e.g.:

```swift
if !connection.isOccupie() && connection.state == .connected then
... connection.disconnected()
else if !connection.isOccupie() && state == .released then
... connection.release()
else if connection.isOccupie() && state == .disconnected then
... connection.reconnecting()
end
```
#### How?
- [Chain Of Responsibility](https://refactoring.guru/design-patterns/chain-of-responsibility){:target="_blank"}: Behavioral Pattern, as the name implies, is a chain where each node has corresponding operations. After inputting data, the node can decide whether to operate or pass it to the next node for processing. Another real-world application is [iOS Responder Chain](https://swiftrocks.com/understanding-the-ios-responder-chain){:target="_blank"}.

> _According to the definition, the Chain of Responsibility Pattern does not allow a node to process data and then pass it to the next node for further processing. **Do it completely or don't do it at all**._

> _For the above scenario, a more suitable pattern might be the [Interceptor Pattern](https://stackoverflow.com/questions/7951306/chain-of-responsibility-vs-interceptor){:target="_blank"}._

![](/assets/78507a8de6a5/1*e8jHpykN1m3Y66Ukf-5OJA.png)

- **Chain of responsibility:** `ConnectionKeeperHandler` is the abstract node of the chain. The `canExcute` method is specifically extracted to avoid the situation where this node processes but then wants to call the subsequent node to continue execution. `handle` is for chaining the nodes, and `excute` is the logic for how to handle the processing.
`ConnectionKeeperHandlerContext` is used to store the data that will be used, and `isOccupie` represents whether the Connection is in use.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState {get}
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//

struct ConnectionKeeperHandlerContext {
    let connection: Connection
    let isOccupie: Bool
}

protocol ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler? { get set }
    
    func handle(context: ConnectionKeeperHandlerContext)
    func execute(context: ConnectionKeeperHandlerContext)
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool
}

extension ConnectionKeeperHandler {
    func handle(context: ConnectionKeeperHandlerContext) {
        if canExcute(context: context) {
            execute(context: context)
        } else {
            nextHandler?.handle(context: context)
        }
    }
}

class DisconnectedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .connected && !context.isOccupie {
            return true
        }
        return false
    }
}

class ReconnectConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.reconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && context.isOccupie {
            return true
        }
        return false
    }
}

class ReleasedConnectionKeeperHandler: ConnectionKeeperHandler {
    var nextHandler: ConnectionKeeperHandler?
    
    func execute(context: ConnectionKeeperHandlerContext) {
        context.connection.disconnect()
    }
    
    func canExcute(context: ConnectionKeeperHandlerContext) -> Bool {
        if context.connection.connectionState == .disconnected && !context.isOccupie {
            return true
        }
        return false
    }
}
let connection = SIOConnection(url: URL(string: "wss://pinkoi.com")!)
let disconnectedHandler = DisconnectedConnectionKeeperHandler()
let reconnectHandler = ReconnectConnectionKeeperHandler()
let releasedHandler = ReleasedConnectionKeeperHandler()
disconnectedHandler.nextHandler = reconnectHandler
reconnectHandler.nextHandler = releasedHandler

disconnectedHandler.handle(context: ConnectionKeeperHandlerContext(connection: connection, isOccupie: false))
```
### Requirement Scenario 4.
#### What?

We need to set up the `Connection` we encapsulated before using it, such as providing a URL Path, setting Config, etc.
#### Why?
- Can flexibly increase or decrease construction openings
- Can reuse construction logic
- If not encapsulated, the external can operate the class unexpectedly
- e.g.:

```
❌
let connection = Connection()
connection.send(event) // unexpected method call, should call .connect() first
✅
let connection = Connection()
connection.connect()
connection.send(event)
// but...who knows???
```
#### How?
- [Builder Pattern](https://refactoring.guru/design-patterns/builder){:target="_blank"}: A creational pattern that allows step-by-step construction of objects and reuse of construction methods.

![](/assets/78507a8de6a5/1*J5eKaks1-fT6u8FojeUkUQ.png)

- **Builder Pattern:** `SIOConnectionBuilder` is the builder for `Connection`, responsible for setting and storing the data used when constructing `Connection`; the `ConnectionConfiguration` abstract interface ensures that `.connect()` must be called before using `Connection` to get the `Connection` instance.

```swift
enum ConnectionState {
    case created
    case connected
    case disconnected
    case reconnecting
    case released
}

protocol Connection {
    var connectionState: ConnectionState {get}
    var url: URL {get}
    var id: UUID {get}
    
    init(url: URL)
    
    func connect()
    func reconnect()
    func disconnect()
    
    func sendEvent(_ event: String)
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never>
}

// Socket.IO Implementation
class SIOConnection: Connection {
    let connectionState: ConnectionState = .created
    let url: URL
    let id: UUID = UUID()
    
    required init(url: URL) {
        self.url = url
        //
    }
    
    func connect() {
        //
    }
    
    func disconnect() {
        //
    }
    
    func reconnect() {
        //
    }
    
    func sendEvent(_ event: String) {
        //
    }
    
    func onEvent(_ event: String) -> AnyPublisher<Data?, Never> {
        //
        return PassthroughSubject<Data?, Never>().eraseToAnyPublisher()
    }
}

//
class SIOConnectionClient: ConnectionConfiguration {
    private let url: URL
    private let config: [String: Any]
    
    init(url: URL, config: [String: Any]) {
        self.url = url
        self.config = config
    }
    
    func connect() -> Connection {
        // set config
        return SIOConnection(url: url)
    }
}

protocol ConnectionConfiguration {
    func connect() -> Connection
}

class SIOConnectionBuilder {
    private(set) var config: [String: Any] = [:]
    
    func setConfig(_ config: [String: Any]) -> SIOConnectionBuilder {
        self.config = config
        return self
    }
    
    // url is required parameter
    func build(url: URL) -> ConnectionConfiguration {
        return SIOConnectionClient(url: url, config: self.config)
    }
}

let builder = SIOConnectionBuilder().setConfig(["test":123])


let connection1 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
let connection2 = builder.build(url: URL(string: "wss://pinkoi.com/1")!).connect()
```

Extension: Here, you can also apply the [Factory Pattern](https://refactoring.guru/design-patterns/factory-method){:target="_blank"} to produce `SIOConnection` using a factory.
### Conclusion!

The above covers the four scenarios and seven Design Patterns used to solve problems encountered while encapsulating Socket.IO.
#### Finally, here is the complete design blueprint for encapsulating Socket.IO


![](/assets/78507a8de6a5/1*DMfFpmF7aVCIIM1dskn97w.jpeg)


Slightly different from the naming and examples in the text, this diagram represents the actual design architecture; we hope to have the original designer share their design philosophy and open-source it in the future.
### Who?

Who designed and was responsible for the Socket.IO encapsulation project?
#### [Sean Zheng](https://www.linkedin.com/in/%E5%AE%87%E7%BF%94-%E9%84%AD-9b3409175/){:target="_blank"}, Android Engineer @ Pinkoi


![](/assets/78507a8de6a5/1*Q_35023LtcZbOtnfvSxv-A.jpeg)


Main architect, Design Pattern evaluation and application, implemented design on the Android side using Kotlin.
#### [ZhgChgLi](https://www.linkedin.com/in/zhgchgli/){:target="_blank"}, Engineer Lead/iOS Engineer @ Pinkoi


![](/assets/78507a8de6a5/1*1NCE3Q7fO5Mh15NT2xoYlA.png)


Platform Team project leader, Pair programming, implemented design on the iOS side using Swift, discussed and raised questions (a.k.a. just talking), and finally wrote this article to share with everyone.
### Further Reading
- [Visitor Pattern in Swift](../ba5773a7bfea/)


For any questions or feedback, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/pinkoi-engineering/%E5%AF%A6%E6%88%B0%E7%B4%80%E9%8C%84-4-%E5%80%8B%E5%A0%B4%E6%99%AF-7-%E5%80%8B-design-patterns-78507a8de6a5){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
