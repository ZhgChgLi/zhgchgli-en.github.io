---
title: "Perfect Implementation of One-Time Offers or Trials in iOS (Swift)"
author: "ZhgChgLi"
date: 2019-04-29T15:30:01.510+0000
last_modified_at: 2024-04-13T07:43:24.841+0000
categories: "ZRealm Dev."
tags: ["ios","ios-app-development","ios-11","swift","mobile-app-development"]
description: "iOS DeviceCheck follows you everywhere"
image:
  path: /assets/c5e7e580c341/1*yXSqoDouuL4Jl2sM49iLHA.png
render_with_liquid: false
---

### Perfect Implementation of One-Time Offers or Trials in iOS (Swift)

iOS DeviceCheck follows you everywhere

While writing the previous [Call Directory Extension](../ac557047d206/), I accidentally discovered this obscure API. Although it's not something new (announced at WWDC 2017/iOS ≥11 support) and the implementation is very simple, I still did a little research and testing and organized this article as a record.
### What can DeviceCheck do?

> **Allows developers to identify and mark the user's device**

Since iOS ≥ 6, developers cannot obtain the unique identifier (UUID) of the user's device. The compromise is to use IDFV combined with KeyChain (for details, refer to [this article](../a4bc3bce7513/)), but in situations like changing iCloud accounts or resetting the phone, the UUID will still reset. It cannot guarantee the uniqueness of the device. If used for storing and judging some business logic, such as the first free trial, users might exploit the loophole by constantly changing accounts or resetting the phone to get unlimited trials.

Although DeviceCheck cannot provide a UUID that will never change, it can "store" information. Each device is given 2 bits of cloud storage space by Apple. By sending a temporary identification token generated by the device to Apple, you can write/read the 2 bits of information.
#### 2 bits? What can be stored?

![](/assets/c5e7e580c341/1*29HWP-4vlMaMng3O2hJSQw.png)

Only four states can be combined, so the functionality is limited.
#### Comparison with original storage methods:

![✓ Indicates data is still there](/assets/c5e7e580c341/1*fhw8C_wb2ehP_xgwMtPmoQ.png)

✓ Indicates data is still there

_p.s. I sacrificed my own phone for actual testing, and the results matched. Even if I logged out and changed iCloud, cleared all data, restored all settings, and returned to the factory initial state, I could still retrieve the value after reinstalling the app._
#### Main operation process:

![](/assets/c5e7e580c341/1*pB25wJ1uEzzznUfT05gfBw.png)

The iOS app generates a temporary token for device identification through the DeviceCheck API, sends it to the backend, which then combines the developer's private key information and developer information into JWT format and sends it to the Apple server. The backend processes the result returned by Apple and sends it back to the iOS app.
### Application of DeviceCheck

Here is a screenshot of DeviceCheck from [WWDC2017](https://developer.apple.com/videos/play/wwdc2017/702/){:target="_blank"}:

![](/assets/c5e7e580c341/1*yXSqoDouuL4Jl2sM49iLHA.png)

Since **each device can only store 2 bits of information**, the possible applications are limited to what the official mentions, such as whether the device has been trialed, paid, or blacklisted, etc., and only one can be implemented.

**Support:** iOS ≥ 11
### Let's start!

After understanding the basic information, let's get started!
#### iOS APP side:
```swift
import DeviceCheck
//....
//
DCDevice.current.generateToken { dataOrNil, errorOrNil in
  guard let data = dataOrNil else { return }
  let deviceToken = data.base64EncodedString()
            
   //...
   //POST deviceToken to the backend, let the backend query the Apple server, and then return the result to the app for processing
}
```

As described in the process, the app only needs to obtain the temporary identification token (**deviceToken**)!

Next, send the deviceToken to our backend API for processing.
#### Backend:

The key part is the backend processing
#### 1. First, log in to the [Developer Console](https://developer.apple.com/account/#/membership/){:target="_blank"} **Note down the Team ID**


![](/assets/c5e7e580c341/1*4_DB0CfHmEqt0HO6mDt8mA.png)

#### 2. Then click on the sidebar [Certificates, IDs & Profiles](https://developer.apple.com/account/ios/certificate/){:target="_blank"} to go to the certificate management platform


![Select "Keys" -> "All" -> Top right corner "+"](/assets/c5e7e580c341/1*zoRcWhT9HcwLXWlmui5wNw.png)

Select "Keys" -> "All" -> Top right corner "+"


![Step 1. Create a new Key, check "DeviceCheck"](/assets/c5e7e580c341/1*QgSEmllj-9AjM74tGucUag.png)

Step 1. Create a new Key, check "DeviceCheck"


![Step 2. "Confirm"](/assets/c5e7e580c341/1*hC4rOksfkDJzo3TWJMFrXg.png)

Step 2. "Confirm"


![Finished.](/assets/c5e7e580c341/1*I9TWEmsmEqZA-01OGq52kA.png)

Finished.

After completing the last step, **note down the Key ID** and click "Download" to download the privateKey.p8 private key file.

At this point, you have all the necessary information for push notifications:
1. Team ID
2. Key ID
3. privateKey.p8

#### 3. Combine according to Apple's [JWT (JSON Web Token)](https://yami.io/jwt/){:target="_blank"} format

**Algorithm:** ES256
```json
//HEADER:
{
  "alg": "ES256",
  "kid": Key ID
}
//PAYLOAD:
{
  "iss": Team ID,
  "iat": request timestamp (Unix Timestamp, EX: 1556549164),
  "exp": expiration timestamp (Unix Timestamp, EX: 1557000000)
}
//Timestamps must be in integer format!
```

Get the combined JWT string: xxxxxx.xxxxxx.xxxxxx
#### 4. Send the data to the Apple server & get the return result

**Like APNS push notifications, there are separate environments for development and production:**
1. Development environment: api.development.devicecheck.apple.com _(For some reason, my development environment requests always fail)_
2. Production environment: api.devicecheck.apple.com

**DeviceCheck API provides two operations:**
**1. Query stored data:** https://api.devicecheck.apple.com/v1/query_two_bits
```plaintext
//Headers:
Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (combined JWT string)

//Content:
device_token: deviceToken (the device token to query)
transaction_id: UUID().uuidString (query identifier, using UUID here)
timestamp: request timestamp (milliseconds), note! This is in milliseconds (EX: 1556549164000)
```

**Return status:**


![[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}](/assets/c5e7e580c341/1*MAa5Z8bK9ppAN6WJxEButg.png)

[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}

**Return Content:**
```json
{
  "bit0": Int: The first bit of the 2 bits data: 0 or 1,
  "bit1": Int: The second bit of the 2 bits data: 0 or 1,
  "last_update_time": String: "Last update time YYYY-MM"
}
```

_p.s. You read it right, the last update time can only be displayed up to year-month_

**2. Write Storage Data:** https://api.devicecheck.apple.com/v1/update_two_bits
```plaintext
//Headers:
Authorization: Bearer xxxxxx.xxxxxx.xxxxxx (combined JWT string)

//Content:
device_token:deviceToken (Device Token to query)
transaction_id:UUID().uuidString (Query identifier, here directly represented by UUID)
timestamp: Request timestamp (milliseconds), note! This is in milliseconds (EX: 1556549164000)
bit0: The first bit of the 2 bits data: 0 or 1
bit1: The second bit of the 2 bits data: 0 or 1
```
#### 5. Get Apple Server Return Result

**Return Status:**

![[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}](/assets/c5e7e580c341/1*MAa5Z8bK9ppAN6WJxEButg.png)

[Official Documentation](https://developer.apple.com/documentation/devicecheck/accessing_and_modifying_per-device_data){:target="_blank"}

**Return Content: None, return status 200 indicates a successful write!**
#### 6. Backend API Returns Result to APP

The APP responds to the corresponding status and it's done!
### Backend Supplement:

It's been a long time since I touched PHP, if interested, please refer to [iOS11で追加されたDeviceCheckについて](https://qiita.com/owen/items/85dff1e45083d2805140){:target="_blank"} for the requestToken.php part
#### Swift Version Demo:

Since I can't provide backend implementation and not everyone knows PHP, here is a pure iOS (Swift) example that handles backend tasks (generating JWT, sending data to Apple) directly in the APP for reference!

You can simulate all content without writing backend code.

> ⚠ Please note _for testing and demonstration purposes only, not recommended for production environment_ ⚠ 

Special thanks to [Ethan Huang](https://medium.com/u/e13f6afcf9b9){:target="_blank"} for providing [CupertinoJWT](https://github.com/ethanhuang13/CupertinoJWT){:target="_blank"} which supports generating JWT content within the iOS APP!

**Main Demo Code and Interface:**
```swift
import UIKit
import DeviceCheck
import CupertinoJWT

extension String {
    var queryEncode: String {
        return self.addingPercentEncoding(withAllowedCharacters: .whitespacesAndNewlines)?.replacingOccurrences(of: "+", with: "%2B") ?? ""
    }
}
class ViewController: UIViewController {

    @IBOutlet weak var getBtn: UIButton!
    @IBOutlet weak var statusBtn: UIButton!
    @IBAction func getBtnClick(_ sender: Any) {
        DCDevice.current.generateToken { dataOrNil, errorOrNil in
            guard let data = dataOrNil else { return }
            
            let deviceToken = data.base64EncodedString()
            
            //In a real situation:
            //POST deviceToken to backend, let backend query Apple server, then return the result to the APP
            
            //!!!!!! The following is for testing and demonstration purposes only, not recommended for production environment!!!!!!
            //!!!!!! Do not expose your PRIVATE KEY casually!!!!!!
                let p8 = """
                    -----BEGIN PRIVATE KEY-----
                    -----END PRIVATE KEY-----
                    """
                let keyID = "" //Your KEY ID
                let teamID = "" //Your Developer Team ID: https://developer.apple.com/account/#/membership
            
                let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60)
            
                do {
                    let token = try jwt.sign(with: p8)
                    var request = URLRequest(url: URL(string: "https://api.devicecheck.apple.com/v1/update_two_bits")!)
                    request.httpMethod = "POST"
                    request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
                    let json: [String: Any] = ["device_token": deviceToken, "transaction_id": UUID().uuidString, "timestamp": Int(Date().timeIntervalSince1970.rounded()) * 1000, "bit0": true, "bit1": false]
                    request.httpBody = try? JSONSerialization.data(withJSONObject: json)
                    
                    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                        guard let data = data else {
                            return
                        }
                        print(String(data: data, encoding: String.Encoding.utf8))
                        DispatchQueue.main.async {
                            self.getBtn.isHidden = true
                            self.statusBtn.isSelected = true
                        }
                    }
                    task.resume()
                } catch {
                    // Handle error
                }
            //!!!!!! The above is for testing and demonstration purposes only, not recommended for production environment!!!!!!
            //
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        DCDevice.current.generateToken { dataOrNil, errorOrNil in
            guard let data = dataOrNil else { return }
            
            let deviceToken = data.base64EncodedString()
            
            //In a real situation:
                //POST deviceToken to backend, let backend query Apple server, then return the result to the APP
            
            //!!!!!! The following is for testing and demonstration purposes only, not recommended for production environment!!!!!!
            //!!!!!! Do not expose your PRIVATE KEY casually!!!!!!
                let p8 = """
                -----BEGIN PRIVATE KEY-----
                
                -----END PRIVATE KEY-----
                """
                let keyID = "" //Your KEY ID
                let teamID = "" //Your Developer Team ID: https://developer.apple.com/account/#/membership
            
                let jwt = JWT(keyID: keyID, teamID: teamID, issueDate: Date(), expireDuration: 60 * 60)
            
                do {
                    let token = try jwt.sign(with: p8)
                    var request = URLRequest(url: URL(string: "https://api.devicecheck.apple.com/v1/query_two_bits")!)
                    request.httpMethod = "POST"
                    request.addValue("Bearer \(token)", forHTTPHeaderField: "Authorization")
                    request.addValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
                    let json: [String: Any] = ["device_token": deviceToken, "transaction_id": UUID().uuidString, "timestamp": Int(Date().timeIntervalSince1970.rounded()) * 1000]
                    request.httpBody = try? JSONSerialization.data(withJSONObject: json)
                    
                    let task = URLSession.shared.dataTask(with: request) { (data, response, error) in
                        guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: .mutableContainers) as? [String: Any], let status = json["bit0"] as? Int else {
                            return
                        }
                        print(json)
                        
                        if status == 1 {
                            DispatchQueue.main.async {
                                self.getBtn.isHidden = true
                                self.statusBtn.isSelected = true
                            }
                        }
                    }
                    task.resume()
                } catch {
                    // Handle error
                }
            //!!!!!! The above is for testing and demonstration purposes only, not recommended for production environment!!!!!!
            //
        }
        // Do any additional setup after loading the view.
    }
}
```

![Screenshot](/assets/c5e7e580c341/1*SwCOuRX_5KD4GsBNfaTQDQ.png)

Screenshot

This is a one-time discount claim, each device can only claim once!
#### Complete project download:


[![](https://opengraph.githubassets.com/5b9e31058f9022c9102e9f1235cb0d3535b7db18c15a0dc2affda91d0f97507e/zhgchgli0718/iOSDeviceCheckExample)](https://github.com/zhgchgli0718/iOSDeviceCheckExample){:target="_blank"}



If you have any questions or comments, feel free to [contact me](https://www.zhgchg.li/contact){:target="_blank"}.



_[Post](https://medium.com/zrealm-ios-dev/ios-%E5%AE%8C%E7%BE%8E%E5%AF%A6%E8%B8%90%E4%B8%80%E6%AC%A1%E6%80%A7%E5%84%AA%E6%83%A0%E6%88%96%E8%A9%A6%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95-swift-c5e7e580c341){:target="_blank"} converted from Medium by [ZMediumToMarkdown](https://github.com/ZhgChgLi/ZMediumToMarkdown){:target="_blank"}._
